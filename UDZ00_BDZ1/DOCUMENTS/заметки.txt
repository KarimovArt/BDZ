Реализовать:
-Работу ЦВХ от прерываний (или ОВХ не от прерываний?)
-фильтры CAN
_СRC EEPROM	-готово
-время теста сильно непохоже
-не блокируются неисправные опт.входы
--ЦВХ1 подключен к ВЫХ1(ипм 100ms). При сработке ЦВХ1 ВЫХ1 срабатывает и происходит ошибка softmem



Структура входов:
1.Статус (ошибка,активен,не активен,был причиной отключения,в обработке)	
2.Вход(ы) подтверждения (только ЦВХ)
3.Режим подтверждения для каждого входа подтверждения (МТЗ,УРОВ)
4.Выходные реле
4.Времена подтверждения для каждого входа подтверждения	(?)
5.Номер (указатель) таймера-обработчика (?)

Структура выходов
1.Режим (имп,длит)
2.Статус (ошибка,активен,не активен,был причиной отключения) Если сработал в импульсе для индикации берем режим.

4.Задержка включения(?)
5.Задержка выключения(?)	пп.4 и 5 можно использовать вместо п.1

Таймеры
1. Получает "№входа(от которого произошел вызов(?)) или возвращает результат работы выхода" №входа(к кот. подкл.МТЗ), 
№выхода, время и режим(MTZ,UROV,ON,OFF) работы 

Режимы:
MTZ	-в течении времени работы сканирует указанный вход;как только на входе ПОЯВЛЯЕТСЯ активный сигнал
-устанавливает в статусе входа от которого произошел вызов "был причиной"
-засекаем время
-запускает таймер задержки включения реле (таймер, в котором указаны №вых, время и режим ON). По окончании этого 
 таймера ставим статус выхода  "был причиной" 
-и запускаем таймер отключения реле (с режимом OFF)(если надо)
Если активный сигнал не появился заканчиваем работу 

UROV	-в течении времени работы сканирует указанный вход;как только на входе ПРОПАДАЕТ активный сигнал заканчиваем работу
Если активный сигнал не пропал 
-устанавливает в статусе входа от которого произошел вызов "был причиной"
-засекаем время
-запускает таймер задержки включения реле (таймер, в котором указаны №вых, время и режим ON). По окончании этого 
 таймера ставим статус выхода  "был причиной" 
-и запускаем таймер отключения реле (с режимом OFF)(если надо)

ON	-по истечению времени включает выход

OFF	-по истечению времени вЫключает выход

Если время ==0 таймер автоматически(?) уничтожается.



Работа:

Превывание делаем по любому перепаду, в нем только считываем состояние входов. Запрет прерывания от конкретного входа
делаем методом переделки входа в выход.

Основной цикл:
1. проверяем ОВХ статус, если==ACT(активный) делаем его выходом hi, включаем в статусе флаг обработки (PROC),
надо еще засечь глобальное и локальное время начала праздника,	читаем источники подтверждений,запускаем необходимые таймеры
2.
	






Работа:

Основной цикл: 	
1. ждем прерывания
2. обрабатываем сработавшие оптические (если есть)
3. сканируем цифровые входы
4. обрабатываем сработавшие цифровые (если есть)
5. отсылка необходимых СМСок
6. сканируем CAN и UART
7. индикация на СД
8. тестирование

 Прерывание
1.1 считываем входы 
1.2 затыкаем сработавшие (наверное методом переделки входа в выход(DDR))- чтоб не было ненужных прерываний)

 Обработка сработавших оптических или цифровых входов
2.1 если подтверждение не требуется:
а) запускаем выходные реле (в нужном режиме)
б) снимаем затычку входа
2.2 если требуется:
а) если МТЗ- запуск таймера INPUT.confTimeMTZ  (со всеми вытекающими)
б) если УРОВ- запуск таймера INPUT.confTimeUROV (со всеми вытекающими)
в) затычку входов снимает таймер
2.3 подготавливаем СМСку

 Отсыл СМСок
3.1 определиться с PID и приоритетами сообщений 

Индикация.
Входы:
4.1 СД не горит- ожидание. 
4.2 СД горит- есть активный сигнал на оптическом входе.
4.3 СД мигает (0.5Гц)-вход был источником аварии. Если выходной ключ не сработал (нет подтверждения) СД погаснет по окончании времени ожидания подтверждения.
4.3 СД мигает (0.3Гц)- неисправность. Вход заблокирован. Неисправность-это если вход стал выходом (DDR)

Выходы:
4.5 СД не горит- выход не активен
4.6 СД горит- выход активирован
4.7 СД мигает (0.5Гц)- сработал импульсно 

